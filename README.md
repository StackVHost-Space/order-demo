# 所用技术
1、redis实现分布式锁、分布式缓存\
2、消息队列实现模块间的交互和状态通知\
3、springSession实现session共享，实现跨域登录\
4、线程池、CompletableFuture实现多线程并发、以及异步调用\
5、消息队列、seate可以实现分布式事务\
6、web服务器的选择，对于高并发系统，tomcat性能不及undertow。\
7、MySQL 作为数据存储服务器;\
8、nacos 作为配置中心以及、配置中心，并且配置持久化策略，保存配置信息；\
9、Gateway 作为 API 网关，承当路由、过滤、断言、负载均衡的功能；\
10、Sentinel 实现链路保护功能，从流量控制、熔断降级、系统负载保护等多
个维度保护服务的稳定性；\
11、利用 SpringBoot 自动配置原理，编写高效代码。\
12、Nginx 实现系统流量入口，以及实现负载均衡、反向代理功能\


# 编码规范 
核心业务功能一般要JAVA代码实现，配合Spring实现，封装成方法。
鉴于对Spring理解以及使用的难度，必须做出编码规范\
1、要考虑线程操作的安全性，避免出现线程不安全的操作，比如，ArrayList慎用，推荐使用CopyOnWriteArrayList。\
2、合理定义变量的作用域，避免内存泄漏风险\
3、对于String字符串的使用，拼接使用StringBuilder实现，并且调用一下intern()方法，减少内存开销\
4、对于事务的使用，特别是@Transacyinal注解的使用,如果使用到了分布式锁，可能会存在事务失效场景\
5、异常处理方面，try-catch的使用,如果使用事务，不能自行处理异常，应该让事务补货去处理。\
6、代码要有注释，包括作者、操作时间、更改原因等待，应该注重可读性而避免过度使用编程技巧。

# 技术架构要点
1、使用redis实现缓存要考虑双写一致性问题、查询缓存的双端加锁,
redis的持久化策略问题，缓存淘汰问题，以及缓存雪崩、缓存穿透、缓存击穿的避免等等；\
2、实现消息队列要保证消息的可靠抵达，保证数据不重复、不乱序，制定好消费策略；\
3、合理的设置线程池参数，合理利用资源；\
4、使用中间件治理服务，进行限流、熔断配置；\
5、分布式锁的使用，必须保证redis的高可用，服务器的高性能、低延迟。\
避免死锁、锁必须可以重入、保证同时只能有一个线程获取锁。自定义分布式锁要遵循aqs规范。
对于高性能、高并发系统，考虑使用MultiLock实现分布式锁。

# 项目部署
1、对于Spring项目，推荐使用k8s+Jenkins部署，实现集群模式，保证系统高可用,实现故障转移；\
2、其他的中间件，使用多主多从的集群模式,并且对配置进行调优，最大限度发挥系统性能/
3、实现快速部署，由开发人员去主导部署，能快速的将项目快速发布到生产环境/
4、提供生产级别的性能监控,可视化界面，根据监控结果进行二次优化\
5、做好数据备份，网络安全\

# 调优方案
对于存量订单10亿, 日订单增长百万量级，高峰期200的qps系统，应该机遇调用，否则无法发挥系统最大性能，
而且存在潜在的内存泄漏、级联崩溃的风险。
1、redis架构：单机32g内存以上,32核心，五主五从架构，保证系统高可用
2、消息队列架构：如果使用kafka，每日百万订单，日活跃可能达到亿级。1 亿/24 小时/60 分/60 秒 = 1150 条/每秒钟。每条日志大小：0.5k - 2k（取 1k）。1150 条/每秒钟 * 1k ≈ 1m/s 。高峰期每秒钟：1150 条 * 20 倍 = 23000 条。
每秒多少数据量：20MB/s。所以，服务器台数选择服务器台数= 2 * （生产者峰值生产速率 * 副本 / 100） + 1= 2 * （20m/s * 2 / 100） + 1= 3 台,建议 3 台服务器。对于磁盘，每天总数据量：1 亿条 * 1k ≈ 100g
100g * 副本 2 * 保存时间 3 天 / 0.7 ≈ 1T ，建议三台服务器硬盘总大小，大于等于 1T。内存选择
，Kafka 内存组成：堆内存 + 页缓存，建议在11g内存以上。CPU 选择，考虑负责写磁盘的线程数，副本拉取线程数，数据传输线程数，选择32核心。
除此之外，还需要对生产者、broker、消费者核心参数调优。
3、mysql架构：10亿级别数据，要保证索引结构在0-3层，尽可能不要超过4层，因此可以对数据表字段进行优化，减少不必要字段，
或者改变字段的数据类型，尽可能减少内存的占用。创建索引结构，加快查找速度，对连接查询、分组查询、排序查询、分页查询优化，尽可能使用
索引去完成。提供缓冲区大小、join缓冲区、sort缓冲区大小，调整redo日志的持久化策略
5、jvm调优，假设部署3台服务器运行代码，百万级别订单，每一台每秒100订单。每个订单对象1kb，1kb*100=100kb，每秒100kb数据，订单服务还涉及其他相关服务，
把对象放大20倍，故每台机器每秒产生2m对象。假设堆内存设置4G，新生代1333m；1333m/2m/63s=11.1分钟产生一次YGC。进一步，提升新时代大小可以把更多对象留在新生代。
假设业务增加到每秒1000次。不扩容。现有新生代配置下，30s就一次YGC。所以堆内存推荐10g以上，32核cpu配置，选择使用g1垃圾回收器。
6、对于SpringBoot项目：使用线程池、CompletableFuture实现多线程并发、以及异步调用，配置缓存的使用，提高性能和吞吐量



# 秒杀（高并发）系统关注的问题
1、服务单一职责+独立部署。\
2、秒杀链接加密，防止恶意攻击，模拟秒杀请求，1000次/s攻击。防止链接暴露，自己工作人员，提前秒杀商品。\
3、库存预热+快速扣减，秒杀读多写少。无需每次实时校验库存。库存预热，数据放到redis中。信号量控制进
来秒杀的请求。\
4、动静分离，nginx做好动静分离。保证秒杀和商品详情页的动态请求才打到后端的服务集群。\
5、恶意请求拦截，识别非法攻击请求并进行拦截。\
6、流量错峰，使用各种手段，将流量分担到更大宽度的时间点。比如验证码，加入购物车。\
7、限流&熔断&降级，限制次数，限制总量，快速失败降级运行，熔断隔离防止雪崩。\
8、队列削峰，所有秒杀成功的请求，进入队列，慢慢创建订单，扣减库存即可。\

# 细节
1、在分布式系统下，秒杀商品的上架需要实现幂等性，加分布式锁，只能让一个服务器节点完成上架功能，该服务器完成上架
功能，释放锁之后，其他节点抢到分布式锁，发现商品已经上架完成就不会在执行
2、使用商品可以秒杀的数量作为信号量：
semaphore.trySetPermits(killCount);
3、秒杀成功：
RSemaphore semaphore = redissonClient.getSemaphore("xxxx");
//TODO 秒杀成功，快速下单
boolean semaphoreCount = semaphore.tryAcquire(num, 100, TimeUnit.MILLISECONDS);
































